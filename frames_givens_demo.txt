
################################################################################

  Python/SymPy/GAlgebra program source code for numerical frame transformation 
and versor decomposition into fixed-axis (Givens') rotations, together with 
demo & test harness, for real  n-space spherical geometry  Cl(n, 0, 0) .  
# Version 1.5; date: 17/06/16; author: Fred Lunnon <Fred.Lunnon@gmail.com> 

  This module is designed with portability and robustness in mind, rather than 
optimal time, space or serpentine virtuosity. [ Customary industrial-scale 
line-breaking conventions have been ignored: I can't make sense of anything 
that doesn't fit on a single page ! ]  Speed might be improved somewhat by 
tailoring specifically to the language and application at hand: GAlgebra seems 
not primarily designed for efficient numerical computation. 

  This module performs reliably on numerical data: although round-off error 
is checked, numerical stability is in practice excellent.  Compared with matrix 
computation, GA involves nontrivial issues concerning continuity and sign, 
resulting in part from mismatches between left- and right-hand frames, 
even- and odd-grade versors, etc, and discussed in the specifications below.  
Competent usage in situations such as continuous motion interpolation require at least awareness of such issues, if only to avoid being snagged by them! 

  Caveat: within this module, matrices and versors compose LEFT-TO-RIGHT, eg. 
    matrix  K  acts on row vector  v  via  v <- v K ; 
    versor  X  transforms  Z  via  Z <- (1/X) Z X ; 
    transformation  X  followed by  Y  requires  X Y ; 
Use by an application with opposite conventions would require the user to 
transpose / revert inputs and outputs, and reverse the order of compositions, 
at the interface. [ It may be feasible to automate this pesky 4-way switch! ] 
(1/X)  denotes matrix transpose or versor reversion; all matrices and versors are implicitly normalised. 

  Specifications and algorithmic details follow: the principal functions are 
    frame_transform_versor(), 
    givens_factor_matrix(),  
    givens_factor_versor(),  
each equipped with verbose option for demonstration and debugging.  
Below the fold the source comprises a substantial testbed harness: 
    spin_disc(), 
    test_main() 
contain examples of usage of the principal functions. 

  The author acknowledges welcome assistance from Alan Cortzen and Warren D. 
Smith, in designing algorithms for frame conversion and Givens factorisation 
resp. 

################################################################################


  Specification:  versor_to_matrix (X), matrix_to_versor (A, Z0 = 0) 

  Input & output:  versor & corresponding matrix, or vice-versa. 

  Method:  The former is trivial: matrix entry  A_ij  is simply the component 
of  e_i  in the action of  X  on  e_j .  The latter in contrast employs 
frame_transform_versor()  to transform the unit frame into one whose vectors are 
the rows of  A ; therefore the same continuity and sign issues are involved. 


  Specification: frame_transform_matrix (F, G) 

  Input:  (Rows of) orthonormal matrices  F, G ; 

  Output:  Matrix  C  such that  G = F C ; 

  Method:  Just  C = (1/F) G , duh! 

  Caveat:  Although frame  F  of vectors is superficially identical to 
(rows of) orthonormal matrix  A , the two transform differently: under 
isometry  S  (as for vectors)  F -> F S = G ; whereas  A -> (1/S) A S = B .  

  Since frame transformation for matrices involves a single multiplication, 
it is tempting to enquire whether  frame_transform_versor()  should imitate  
givens_factor_versor() , simply converting both frames to matrices  F,G  
then  (1/F) G  back to a versor.  This fails for two reasons: firstly, GA instead 
requires  Z  where  B = (1/Z) A Z ; secondly, matrix_to_versor() requires 
frame_transform_versor() in turn, so the final step is infinitely recursive! 


  Specification: frame_transform_versor (F, G, verb = False, Z0 = 0) 

  Input:  Orthonormal numerical versors  F_1 .. F_n ; G_1 .. G_n  in  Cl(n, 0) ; 
optional boolean  verb  invokes verbosity;  Z0  recalls previous output. 

  Output:  Normal versor  Z  such that  G_k = (1/Z) F_k Z  for  k = 1 ..n . 
An error message results if output rounding error exceeds global bound  eps . 

  Method:  At stage  k  start,  H_i = G_i  for  i < k , and is orthogonal 
to  G_1 .. G_(k-1)  for  i >= k .  Versor  R  transforms  H_k  into  G_k  
without altering  H_1 .. H_(k-1) : if angle  u  between them exceeds 
threshold (say  pi/8 ) assign reflection  R , otherwise rotation ; 
this avoids singularities at  u = 0, pi  for reflection, rotation resp. 

  s,t  track sign-change due to reflection at stage  k  and overall resp. 
Pseudocode below omits implicit renormalisation, and error / continuity checks.  
Note that finally at  k = n , always  R = +/-1  approx. 

  Pseudocode:  
    lip := 0.7; 
    H := F;  Z := I;  s := +1; 
    
    FOR  k := 1 .. n  DO  
      IF  <H_k G_k>_0 >= lip  # angle below threshold? 
      THEN  R := 1 + H_k G_k;  t := +1;  # rotate 
      ELSE  R := G_k - H_k;  t := -1;  FI  # reflect 
      FOR  i = k..n  DO  H_i := t <(1/R) H_i R>_1;  OD  # apply to frame 
      Z := Z R;  s := s t;  # update  Z  and sign 
    OD  # finally  H  =  (1/Z) F Z  =  +/-G ,  Z  =  prod_k R ; 

  Continuity and sign issues:  Frames  F, G  may have mismatched senses: one 
left- and the other right-handed, their corresponding orthonormal matrices 
having different determinants.  On termination of the loop above, the result 
is  H = -G  instead; when  n  is even, this can be corrected via replacing  Z  
with its dual, otherwise an error message results. 

  Again, the sign of  Z  as earlier computed may flip randomly in the course of 
a sequence of transformations intended by the user to approximate continuity. 
To avoid this, option  Z0  should be loaded with the previous output: either 
the algorithm  adjusts the output sign to match, or an error message results. 

  Worse still when  n  is odd, it is possible that  Z  might flip between 
the expected versor and its dual: to maintain continuity, the algorithm 
adjusts this situation as well. [ Truly, nothing is simple! ] 


  Specification: givens_factor_matrix (B, verb = False) 

  Input:  Orthonormal order-n  matrix  B ; optional boolean  verb  invokes 
verbosity. 

  Output:  Sequence of Givens' rotations  R_k  such that  B = |B| R_1 .. R_m , 
where  m = n(n-1)/2 .  An error message results if output rounding error 
exceeds global bound  eps . 

  Method:  With  A = (1/B)  initially, at stage  k  clear some  A_ij := 0  
in the upper triangle  i < j  via post-multiplication by Givens' rotation  
R_ij(u_k) .  Orthonormality is conserved; finally the upper triangle is empty, 
and via orthogonality so is the lower, and  A  has been reduced to unit 
matrix.  

  Sequence  (i,j)_k  is designed to avoid overwriting previously established zeros, in either upper or lower triangle: this method utilises 
    (i,j)  =  (1,2), (1,3), (2,3), (1,4), (2,4), (3,4), ...  
Both angles  u, pi-u  clear entry  A_ij  equally effectively: the choice made 
ensures  B_ii > 0  subsequently, so that the diagonal becomes finally positive. 

  Pseudocode:  
    A := (1/B);  C := I;  
    FOR  j := 1 .. n  DO  FOR  i := 1 .. j-1  DO  
        s := A_ij;  t := A_ii;  r := sqrt(s^2 + t^2);  
        R_k := givens(i, j, t/r, s/r);  # t/r, s/r = cos(u), sin(u) 
        A := A R_k;  C := C R_k;  OD OD  # new A_ij ~ 0 , A_ii > 0 
    # finally  A ~ (1/B) R[1] ... R[m] ~ diag(1, ..., 1, +/-1) ,  C ~ B ? 

  Here  givens(i, j, cosu, sinu)  denotes Givens' matrix  R_ij(u) , rotation 
in the  (x_i, x_j)-plane through angle  u : its components are those of the 
unit matrix, excepting 
    R_ii = cosu ,  R_jj = sinu ,  R_ij = -sinu ,  R_ji = sinu ; 
post-multiplication by  R  alters only columns  i,j  of  A , and conserves 
orthonormality. 

  Sign issues:  Product  R_1 .. R_m = B  when  B  is special, representing a 
direct, "orientation-preserving" isometry, with determinant  |B| = 1 ; 
otherwise  R_1 .. R_m = -B . 


  Specification:  givens_factor_versor (Y, verb = False) 

  Input:  spherical versor  Y  in dimension  n ; optional boolean  verb  
invokes verbosity. 

  Output:  Sequence of grade-2 Givens'  R_k  such that  Y = R_1 .. R_m M , 
where  m = n(n-1)/2 , and  M  is monomial.  An error message (or two) results 
if output rounding error exceeds global bound  eps . 

  Method:  Y  is converted to matrix for  givens_factor_matrix()  to process, 
and the result converted back via  matrix_to_versor() .  Then the trouble 
starts ... 

  Sign issues:  When  Y  has even grade, the product may fail to have the same 
sign as  Y , and the sign of  R_m  is adjusted to correct this.  Otherwise, 
factorisation is only possible up to an extra monomial  M  --- the dual of 
either  e_n  or  1  for  n  even or odd resp. ---  which is printed with an 
error message.  [ Ideally the algorithm should ensure that  M = e_n ; 
however, it is not at present clear how to achieve this. ] 


  Specification:  instantiate_GA (n)  

  Input:  dimension  n  of algebra. 

  Output:  GA, n, m  for assignment to global variables. 

  Caveat:  Must be invoked at outer level of user program.  User generator identifiers must assigned explicitly, their variables recovered from global  
gene[]  list --- see  spin_disc()  source for example. 


  Specification:  test_main () 

  Output:  Verbose printout from the 3 principal functions, illustrating their 
methods in operation.  Source code comprises simple examples of their usage. 


  Specification:  spin_disc (l = 20)  

  Input:  Number of steps  l  of rotation demo (default  20 ) 

  Output:  Printout illustrating spin continuity under continuous rotation, 
and matrix-versor relationship.  Source code contains examples of usage. 


################################################################################

  

